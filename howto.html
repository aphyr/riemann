---
title: Riemann - Howto
layout: default
---

<style>
  body {
    background: #ff9000; /* Old browsers */
    background: -moz-radial-gradient(center, ellipse cover,  #ff9000 0%, #d14c00 100%); /* FF3.6+ */
    background: -webkit-gradient(radial, center center, 0px, center center, 100%, color-stop(0%,#ff9000), color-stop(100%,#d14c00)); /* Chrome,Safari4+ */
    background: -webkit-radial-gradient(center, ellipse cover,  #ff9000 0%,#d14c00 100%); /* Chrome10+,Safari5.1+ */
    background: -o-radial-gradient(center, ellipse cover,  #ff9000 0%,#d14c00 100%); /* Opera 12+ */
    background: -ms-radial-gradient(center, ellipse cover,  #ff9000 0%,#d14c00 100%); /* IE10+ */
    background: radial-gradient(ellipse at center,  #ff9000 0%,#d14c00 100%); /* W3C */
    filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#ff9000', endColorstr='#d14c00',GradientType=1 ); /* IE6-9 fallback on horizontal gradient */
  }
</style>

<div class="row">
  <h1 class="twelvecol">A <span class="focus">guide</span> to working with Riemann</h1>
</div>

<div class="row">
  <div class="sixcol">
    <p>This is not a comprehensive guide to everything in Riemann, but it can
    get you started and help solve specific problems. Want to add your own
    article to this page? <a href="#help-write-documentation">Send me a pull
      request!</a></p>
  </div>

  <div class="sixcol last">
    <p>Once you know where to look, you can learn more by reading the <a
      href="api">API docs</a> (especially <a
      href="api/riemann.streams.html">riemann.streams</a>), and <a
      href="https://github.com/aphyr/riemann/tree/master/src/riemann">the
      source</a>.  I try hard to write readable code. The <a
      href="https://github.com/aphyr/riemann/tree/master/test/riemann/test">test
      suite</a> is also a great place to look for use examples.</p>
  </div>
</div>

</div><!-- container -->
<div class="light">

<div class="container">

  <script type="text/javascript" charset="utf-8">
    $(document).ready(function() {
      $("#toc").tableOfContents(null, {
        startLevel: 2,
        depth: 2,
        topLinks: true
      });
    });
  </script>

  <div class="row">
    <div class="twelvecol">
      <div id="toc">
      </div>
    </div>
  </div>

  <div class="row">
    <div class="twelvecol">

<h2>Running Riemann</h2>

<div class="row">
  <div class="sixcol">
    <h3>Changing the config</h3>
    <p>If you use the Debian or Centos packages, Riemann adds a
    <code>riemann</code> user, stores its configuration in
    <code>/etc/riemann/riemann.config</code>, and logs to
    <code>/var/log/riemann.log</code>. You should always tail the log file when
    working with Riemann; it'll alert you to configuration errors and help you
    debug your streams.</p>
  </div>
  <div class="sixcol last">
{% highlight sh %}
tail -F /var/log/riemann.log
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>In another terminal, use your favorite editor to open
    <code>/etc/riemann/riemann.config</code>. Let's add a logging stream, so we
    can see all events that pass through the streams. <code>#(info %)</code>
    expands into <code>(fn [x] (info x))</code>, which is a function that takes
    an event and logs it at the INFO log level.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %} 
(streams
  index
  ...
  #(info "received event" %))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Now we need to reload the config file. Riemann will respond to SIGHUP,
    or you can use the init scripts. You'll see a message about reloading the
    config in the Riemann log. If you make a mistake, like a syntax error,
    Riemann will continue running with the old config and won't apply the new
    one. Instead, it'll log an explanation of the problem, so you can
    investigate and fix it.</p>

    <p>Now that the config has been reloaded, you should see events flowing by
    in the log. Some come from external sources, like riemann-health or your
    own programs. Others are generated by Riemann internally, as a part of its
    internal performance instrumentation. You can insert logging statements
    anywhere in your streams to verify what kind of events are flowing through
    that point.</p>

    <p>Reloading is experimental, and is subject to the normal Clojure rules
    about <code>(def)</code> and <code>(defn)</code>. To avoid confusion, use
    <code>let</code> bindings instead of <code>def</code>; it'll guarantee
    reloads work correctly. If reloads seem broken, you might need to do a
    full restart for your changes to take effect.</p>
  </div>

  <div class="sixcol last">
{% highlight sh %}
sudo service reload riemann
{% endhighlight %}
  </div>
</div>

<h3>Putting Riemann into production</h3>
<div class="row">
  <div class="sixcol">
    <p>Riemann has three main parts: clients, the server, and dashboard. By
    default, all listen on the loopback interface. You'll need to configure
    each to listen to an appropriate interface for your environment. On the
    host that runs the Riemann server, open
    <code>/etc/riemann/riemann.config</code>, and change the host that Riemann
    binds to. To listen on all interfaces, use <code>0.0.0.0</code>.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(let [host "0.0.0.0"]
  (tcp-server :host host)
  (udp-server :host host)
  (ws-server  :host host))
{% endhighlight %}
  </div>
</div>
<div class="row">
  <div class="sixcol">
    <p>Now we need to reload Riemann to tell it about our changes.</p>
  </div>
  <div class="sixcol last">
{% highlight sh %}
sudo service riemann reload
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>To change the address that the dashboard binds to, see <a href="https://github.com/aphyr/riemann-dash">riemann-dash's README</a>.</p>
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Riemann-dash only serves some JS code and a small piece of
    configuration; the browser connects directly to Riemann's websocket server
    to receive events. To connect the dashboard to a remote Riemann server,
    double-click the text box in the top right of the dashboard, and change the
    address from <code>127.0.0.1:5556</code> to your Riemann server's host and
    port. When you hit enter, the browser will initiate a websocket connection
    to that address and begin displaying events. Hit <code>s</code> to save the
    new dash config; the dashboard will connect to that address every time you
    load the page.</p>
   
    <p>If the dashboard is unable to connect to the Riemann websocket server,
    you'll see an alert pop up every few seconds. Check that the server is
    running, that the Riemann websocket server is reachable from your browser,
    that you used the correct host and port, and so on.<p>

    <p>If you don't see *anything* on the dash, but it connected successfully,
    you may not have any events to show, or you may not have set up any
    views.</p>
  </div>
</div>

<div class="row">
  <h3>Change the log file</h3>

  <div class="sixcol">
    <p>To log to a file, just say</p>

{% highlight clj %}
(logging/init :file "/path/to/some/riemann.log")
{% endhighlight %}

    <p>If you'd prefer to only log to the console, just leave out :file</p>

{% highlight clj %}
(logging/init)
{% endhighlight %}
  </div>
</div>

<div class="row">
<h3>Overriding Riemann functions</h3>

<div class="sixcol">
  <p>Sometimes, something in Riemann doesn't work the way you'd like. When this
  happens, you can redefine any function in Riemann in the config file. Just
  switch to the appropriate namespace, redefine the function, and switch back to
  <code>riemann.config</code>.</p>

  <p>For instance, let's say you wanted to change how emails are formatted. The
  namespace <code>riemann.email</code> has a function called <code>body</code>,
  which accepts a sequence of events and returns a string. We'll override it in
  our config file:</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(ns riemann.email)
(defn body [events]
  ; pr-str formats events as a clojure-readable string.
  (pr-str events))
(ns riemann.config)

; And then your servers, streams, etc...
(tcp-server ...)
(streams ...)
{% endhighlight %}
  </div>
</div>

<h3>Connecting to the REPL</h3>

<p>Riemann has an nREPL server built in. You can enable this in your config with:</p>

{% highlight clj %}
(repl-server :host "127.0.0.1")
{% endhighlight %}

<p>You can then use <code>lein</code> to to connect to it (make sure you have leiningen 2):</p>

{% highlight sh %}
git clone git://github.com/aphyr/riemann.git
cd riemann
lein repl :connect 127.0.0.1:5557
{% endhighlight %}

<p>A very useful thing you can do from the REPL is to reload the config file, this is handy
when testing locally:</p>

{% highlight clj %}
user=> (riemann.bin/reload!)
{% endhighlight %}

<h2>Instrumenting your systems</h2>

<h3>Measure CPU, memory, and disk use</h3>

<p><a href="https://github.com/aphyr/riemann-tools">Riemann-tools</a> includes
a program called riemann-health, which measures the local host's cpu, memory,
and disk use. You can install it from rubygems:</p>

{% highlight sh %}
gem install riemann-tools
{% endhighlight %}

<p>... and run riemann-health with the address of your riemann server like so:</p>

{% highlight sh %}
riemann-health --host 1.2.3.4
{% endhighlight %}

<p>Riemann-health reports utilization *fractions* by default, ranging from zero
to one. Load average is divided by the number of cores, and disk use by
capacity. You can adjust the polling interval, what percentage of cpu use is
considered critical, and more. <code>riemann-health --help</code> will tell you more.</p>

<h3>Monitor Riak</h3>

<p><a href="https://github.com/aphyr/riemann-tools">Riemann-tools</a> includes
riemann-riak, which uses riak's HTTP stats interface, some filesystem checks,
and optionally, some erlang RPC requests to measure Riak's get and put
latencies, request throughput, ring status, and disk use. Run riemann-riak on
each Riak node.</p>

{% highlight sh %}
gem install riemann-tools
riemann-riak --host 1.2.3.4
{% endhighlight %}

<p>Riemann-riak comes with defaults for the riak .deb packages shipped by
Basho, but it's tunable for other configurations. See <code>riemann-riak
  --help</code> for more options.</p>

<h2>Working with streams</h2>

<h3>Filter events</h3>

<p>Often, we want to do some operation only on a subset of events flowing
through a stream. For instance, we might only want to email events which have
the state "error". The basic filtering streams are <a
  href="api/riemann.streams.html#var-where">where</a>, her less magical sister
<a href="api/riemann.streams.html#var-where*">where*</a>, <a
  href="api/riemann.streams.html#var-match">match</a>, <a
  href="api/riemann.streams.html#var-tagged-all">tagged-all</a> and <a
  href="api/riemann.streams.html#var-tagged-any">tagged-any</a>, and <a
  href="api/riemann.streams.html#var-expired">expired</a>. Most of the time,
you'll use <code>where</code>.</p>

{% highlight clj %}
(streams
  (where (state "error")
    ; Only events which have the state "error" are passed on to the email
    ; stream:
    (email "delacroix@vonbraun.com")))
{% endhighlight %}

{% highlight clj %}
; Where is powerful stuff. You can match using equality:
(where (host "von braun"))

; Regular expressions
(where (description #"an+elids"))

; The presence of a given tag
(where (tagged "mutant"))

; There are also streams specifically for selecting events which have some,
; or all, of a set of tags.
(tagged-any ["cat" "dog"] (with :service "animals/sec" (rate 1 index)))
(tagged-all ["ops" "ddos"] (email "ops@githug.com"))

; tagged is shorthand for tagged-all:
(tagged "page" page-ops)

; Arbitrary functions on values
(where (>= (* metric 1000) 2.5))

; Which makes range queries easy
(where (< 5 metric 10))

; Boolean operators
(where (not (or (tagged "www")
                (and (state "ok") (nil? metric)))))

; And arbitrary functions
(defn global? [event] (nil? (:host event)))
(where (global? event))
{% endhighlight %}

<p>Where streams forward an event to their children when the predicate matches.
When the predicate *doesn't* match, where will forward events to any children
in an <code>(else)</code> block.</p>

{% highlight clj %}
(where (or (service "ok") (service "warning"))
  index
  (else
    (email "ops@foo.com")))
{% endhighlight %}

<h3>Set thresholds</h3>

<p>You can use (where) to alert you when a metric goes out of bounds. Where the
metric falls between zero and five, inclusive, index it with state "ok".
Otherwise, index it with "warning":</p>

{% highlight clj %}
(streams
  (where (<= 0 metric 5)
    (with :state "ok" index)
    (else
      (with :state "warning" index))))
{% endhighlight %}

<h3>Detect state transitions</h3>

<p>The <a href="api/riemann.streams.html#var-changed">changed</a> stream
forwards on events when some fields of that event change. For instance, you
can send an email whenever the state changes:</p>

{% highlight clj %}
(streams
  (by [:host :service]
    (changed :state
      (email "ops@startup.io"))))
{% endhighlight %}

<p>Note that we use <code>(by)</code> so that each distinct host and service
track their changes independently. Otherwise, we'd get alerts when service A
reported "ok" and service B reported "down". There's a shorthand for this:</p>

{% highlight clj %}
(streams
  (changed-state
    (email "ops@startup.io")))
{% endhighlight %}

<p>When you start Riemann, it doesn't know what the previous state was. By
default, <code>changed</code> will forward on the first event it receives. You
can tell <code>changed</code> and <code>changed-state</code> to *assume* an
initial state with the <code>:init</code> option:</p>

{% highlight clj %}
(streams
  (changed-state {:init "ok"}
    (email "ops@startup.io")))
{% endhighlight %}

<p>I tend to include this snippet in my riemann configurations so I can keep
track of which services are starting, crashing, and gracefully restarting.</p>

<h3>Measure your app's latency profile</h3>

{% highlight clj %}
; Imagine you wanted to know the time it takes for your app's API requests
; to complete. The API emits events like:
;
; {:service "api req"
;  :metric: 0.240} ; 240 milliseconds
;
; So first, we select only the API requests

(where (service "api req")

       ; Now, we'll calculate the 50th, 95th, and 99th percentile for all
       ; requests in each 5-second interval.

       (percentiles 5 [0.5 0.95 0.99]

                    ; Percentiles will emit events like
                    ; {:service "api req 0.5" :metric 0.12}
                    ; We'll add them to the index, so they can show up
                    ; on our dashboard.

                    index)

       ; What else can we do with API requests? Let's figure out the total
       ; request rate. (rate interval & children) sums up metrics and
       ; divides by time.

       (rate 5)

       ; But this isn't quite right--these event metrics are *times*, so
       ; we're actually calculating the number of seconds spent by the API,
       ; each second. So we *set* the metric of every event to 1, *then*
       ; take the rate:

       (with :metric 1.0 (rate 5 index))

       ; (with) takes each event and calls (rate) with a *changed*
       ; copy--one where :metric is always 1. Then (rate) adds up all those
       ; 1's over five seconds, and sends that metric to the index.

       ; (with) has a counterpart, by the way: (default). It works exactly
       ; the same, but it only alters the event when the value is nil. Both
       ; with and default accept maps as well:

       (default {:state "ok" :ttl 60} index)
)))
{% endhighlight %}

<h3>Report exceptions</h3>

<p>Where you handle exceptions in your application, you can also submit an
event to Riemann. I usually set the service to the application name, include
the stacktrace as the description, and tag the event with both "exception" and
the classname of the exception.</p>

{% highlight clj %}
(tagged "exception"
  (email "ops@foocorp.com"))

(tagged-all ["exception" "DatabaseError"]
  (email "db@foocorp.com"))
{% endhighlight %}

<p>It's also easy to track the *rate* of exceptions per second, so you can
graph how many unexpected failures occur per day, and determine which services
need the most attention.</p>

{% highlight clj %}
(where (tagged "exception")
  (with :metric 1.0
    (by :service
      (adjust [:service (str " exception rate")]
        (rate 10 index graph)))))
{% endhighlight %}

<h3>Roll up and throttle events</h3>

<p>Sometimes, when things break, they submit a *ton* of events. Maybe you
receive sixty thousand exceptions in five minutes. You need to know that a
problem exists--but don't need to know about *every single failure*. Riemann
has two streams for controlling the rate of events.</p>

<p><a href="api/riemann.streams.html#var-rollup">rollup</a> will allow a few
events to pass through readily. Then it starts to accumulate events, rolling
them up into a list which is submitted at the end of a given time interval.</p>

<p>Let's define a new stream for alerting the operations team, which sends only
five emails per hour (3600 seconds). We'll receive the first four events
immediately--and at the end of the hour, a single email with a summary of all
the rest.</p>

{% highlight clj %}
(def tell-ops (rollup 5 3600 (email "ops@rickenbacker.mil")))

(streams
  (where (state "error") tell-ops)
  (tagged "exception" tell-ops))
{% endhighlight %}

<p>Rollup holds on to every event, which can use a lot of memory. Sometimes
it's OK to drop some events instead of delivering them. That's where <a
  href="api/riemann.streams.html#var-throttle">throttle</a> comes in: it allows
the first five events through, then ignores all the rest for an hour.</p>

{% highlight clj %}
(def tell-ops (throttle 5 3600 (email "ops@rickenbacker.mil")))
{% endhighlight %}

<p>And naturally, you can combine throttle and rollup to preserve *some*
events, but not allow unbounded memory use:</p>

{% highlight clj %}
(def tell-ops
  (throttle 1000 3600
    (rollup 5 3600
      (email "ops@rickenbacker.mil"))))
{% endhighlight %}

<h3>Detect down services</h3>

<p>Each event has a TTL, which states how many seconds the event is valid for
after its given time. When a service crashes catastrophically, it will stop
submitting events and its events in the index will become stale. Periodically,
the index sweeps out events past their lifetime, deletes them from the index,
and streams an event for that host and service with state "expired".</p>

<p>You can control how often the index scans for expired events with
<code>periodically-expire</code>. Here, we check every ten seconds. If you
*don't* want events to expire from the index, you can delete this line from
your config:</p>

{% highlight clj %}
(periodically-expire 10)
{% endhighlight %}

<p>If events have no TTL given, the index assumes their TTL is 60 seconds. You
can provide a default TTL for any incoming events that don't provide one:</p>

{% highlight clj %}
(streams
  (default :ttl 10
    ; your streams here
    ))
{% endhighlight %}

<p>Now, any services that fail to check in every ten seconds will expire
(unless they give a different TTL). Since expired events have a different
state, any (changed :state) streams will detect the transition and can alert
you:</p>

{% highlight clj %}
(streams
  (changed :state {:init "ok"}
    (email "ops@foo.com")))
{% endhighlight %}

<p>You can also explicitly filter expired events:</p>

{% highlight clj %}
(streams
  ; Email any expired event
  (expired (email "ops@foo.com"))

  ; Process only events which are *not* expired
  (where (not (expired? event))
    ...))
{% endhighlight %}

<p>By default, Riemann copies <code>[:host :service]</code> to expired events.
You can control what keys from events are copied onto expired events by
passing <code>:keep-keys</code> to <code>periodically-expire</code>:</p>

{% highlight clj %}
(periodically-expire 10 {:keep-keys [:host :service :tags]})
{% endhighlight %}

<p>With that in place, you can filter expired events on tags. This way, your app
can decide whether an event is worthy of an alert by tagging it:</p>

{% highlight clj %}
(streams
  (expired
    (tagged "notify-me" (email "ops@foo.com"))))
{% endhighlight %}

<h3>Group events in time</h3>

<p>Sometimes you want to ask a question about the last few minutes, or of
groups of 10 consecutive events at a time.</p>

<ul>
  <li><a href="api/riemann.streams.html#var-moving-time-window">moving-time-window</a> forwards the last n seconds of events</li>
  <li><a href="api/riemann.streams.html#var-moving-event-window">moving-event-window</a> forwards the last n events</li>
  <li><a href="api/riemann.streams.html#var-fixed-time-window">fixed-time-window</a> forwards events from disjoint n-second windows</li>
  <li><a href="api/riemann.streams.html#var-fixed-event-window">fixed-event-window</a> forwards disjoint sequences of n events</li>
</ul>

<h3>Find the host using the most CPU</h3>

<p>If you're running riemann-health, all hosts will report events like
<code>{:service "cpu" :host "foo" :metric 0.12}</code>. You want to know which
host is under the heaviest CPU load. The <code>coalesce</code> stream remembers
the last events from each host and service, and sends them all as a vector to
its children. We can map that vector of events to a single event--the one with
the largest metric--using folds/maximum. Then we just set the service and host,
since this event pertains to the system as a whole.</p>

{% highlight clj %}
(coalesce (smap folds/maximum
  (with {:service "Max CPU" :host nil} prn)))
{% endhighlight %}

<h3>Alerting when a certain percentage of events happen</h3>

<p>Sometimes you'll have a service that will fail. You might expect one or two
failures, but if you get over a certain percentage of failures you want to be
notified. In this case you can use a <code>fixed-time-window</code>

{% highlight clj %}
(streams
  (where (and metric (service "app1")(tagged "sign_in"))
    ; We want to get alerted about failed sign ins. However we expect that there will be failures
    ; due to incorect passwords etc. So we only want to get alerted if more than 50% of the signins
    ; in a 60 second period are failures. The app tags failed signins with a warning state.
    ;
    ; fixed-time-window sends a vector of events out every 60 seconds
    (fixed-time-window 60
      ; smap passes those events into a function
      (smap (fn [events]
        ; we include a function here filter the vector for all of the "warning" events and count them
        ; we will then count the total of the events
        ; finally work out the percentage
        (let [percent (/ (count (filter #(= (:state %) "warning") events))
                         (count events))]
                         ; take an action on the value of percent, in this example we imagine that the
                         ; page-ops and mail-devs functions can take strings
                         (cond
                           (> percent 0.7) (page-ops (format "sign_in is CRITICAL: %f percent" (float percent)))
                           (> percent 0.5) (mail-devs (format "sign_in is BAD: %f percent" (float percent)))
                           :else (prn (format "sign in is %f" (float percent)))
                           ))))))
  ))
{% endhighlight %}

<h3 id="create-your-own-stream-function">Create your own stream function</h3>

<p>A stream is a function that takes a variable number of child streams and returns a function that takes an event and responds to that event.</p>

<p>Let's create a trivial example.</p>

{% highlight clj %}
(defn hello-stream [& children]
  (fn [e] (let [new-event (assoc e :hello :world)]
    (call-rescue new-event children))))
{% endhighlight %}

<p>Our stream returns a function that when it receives an event, adds a new key-pair via <code>assoc</code> and then uses <code>call-rescue</code>, a standard library function, to pass the event on to all the child streams it was passed.</p>

<p>Add this new stream to the list of event streams.</p>

{% highlight clj %}
(streams (hello-stream prn))
{% endhighlight %}

<p>Now when you pass an event into Riemann you should see the event printed out with an added key-value pair of <code>:hello :world</code>.</p>

<p>Streams all essentially work in this way, if you look at the source code of the Streams namespace in <code>streams.clj</code>. You can find a few simple examples in the functions <code>match</code>, <code>expired</code>, <code>under</code> and <code>over</code> which filter whether the event is passed along the event stream.</p>

<h2>Working with the dashboard</h2>

<h3>Application specific host grouping</h3>
<p>
It is generally desirable to group all the hosts for a specific service into a
single dashboard view. For example, all the web servers are in single view while
all the database servers are in another view.
</p>

<p>
This is usually not an issue when you are sending custom metrics using Riemann
client. However, there are cases where you are using something that you do not
control how the metrics are being sent. i.e., Riemann-tools.
</p>

<p>
Since Riemann-tools scripts are application agnostic, in order for the
dashboard view to group hosts, we must inject some application specific
information into the tags field. Tags is a collection of arbitrary strings.
In the case of Riemann-tools scripts you can pass in arbitrary strings on the
command line.
</p>

<p>
  <code>riemann-health --host 127.0.0.1 --tag "prod" --tag "webserver"</code>
</p>

<p>In this case, the above health check will include two extra tags "prod" and
"webserver". On the dashboard side, you can create a grid view which contains
the following query: </p>

<p><code>(tagged "prod" and tagged "webserver")</code></p>

<p>The tagged keyword in the query ensures that the given tag is present in the
list of tags for a given event. This query will return only "prod" and
"webservers" hosts.</p>

<h3>Count total number of hosts</h3>

<p>Sometimes it is useful to know how many hosts are sending data to Riemann.
This is especially useful in cloud environments where nodes are constantly
scaling up and down.</p>

<p>We'll create a new stream that will keep track of unique hosts and index it
as a new service so the Riemann dashboard can query it.</p>

{% highlight clj %}
(let [index (default :ttl 300 (update-index (index)))]
    (streams
      prn
      index))
{% endhighlight %}

<p>Since stream is just a function that takes an event as an argument, we'll add
an anonymous function to <code>(streams)</code> that will store a set of hosts.</p>

{% highlight clj %}
(let [hosts (atom #{})]
  (fn [event]
    (swap! hosts conj (:host event))
    (prn :hosts @hosts)
    (index {:service "unique hosts"
            :time (unix-time)
            :metric (count @hosts)})))
{% endhighlight %}

<p>On the dashboard you can create a gauge view with the following query:</p>

<p><code>(service = "unique hosts")</code></p>

<p>If you created the query correctly, you should see a "Total Count" gauge.</p>

<h3>Count number of hosts by application group</h3>

<p>Let's say events from each host come with a particular tag, like
"production" or "staging".  You'd like to know how many hosts have a certain
tag. In riemann.config, try this stream:</p>

{% highlight clj %}
(let [hosts (atom {}) host (atom #{})]
  (fn [event]
    (let [tag-str (keyword (clojure.string/join "-" (:tags event)))]
    (swap! hosts assoc tag-str (conj (tag-str @hosts #{}) (:host event)))
    (index {:service (str (name tag-str) "-count")
            :time (unix-time)
            :metric (count (tag-str @hosts))})
    (swap! hosts (atom {})))))
{% endhighlight %}

<p>The above code will create a unique service using all your tags with "-count"
appended to the end. For example, if you have "webserver" and "prod" tags, the
new service that will count unique hosts will be named "webserver-prod-count".
In your dashboard you can query it like below:</p>

<p><code>(service = "webserver-prod-count")</code></p>

<p> If you create a new gauge view with that query, you will get the current
count of all your production web servers.  </p>

<h2>Integrating with other systems</h2>

<h3>Send email</h3>

<p><code>riemann.email</code> can send single events--or vectors of events--via email:</p>

{% highlight clj %}
(def email (mailer {:from "riemann@trioptimum.com"}))

(streams
  (where (state "critical")
    (email "shodan@tauceti.five")))
{% endhighlight %}

<p>You can use any options for <a href="https://github.com/drewr/postal">Postal</a>:</p>

{% highlight clj %}
(mailer {:from "riemann@trioptimum.com"
         :host "mx1.trioptimum.com"
         :user "foo"
         :pass "bar"})
{% endhighlight %}

<h3>Forward to Graphite</h3>

<p>First, you define a client to graphite, which maintains a connection pool:</p>

{% highlight clj %}
(def graph (graphite {:host "my.graphite.server"}))
{% endhighlight %}

<p>Then, use the client as a stream:</p>

{% highlight clj %}
(streams
  (where (service "thing-to-graph")
    graph))
{% endhighlight %}

<p>Or just graph everything:</p>

{% highlight clj %}
(streams
  graph)
{% endhighlight %}

<h3>Forward to Librato Metrics</h3>

<p>Create a client for librato-metrics with your username and API key:</p>

{% highlight clj %}
(def librato (librato-metrics \"aphyr@aphyr.com\" \"abcd01234...\"))
{% endhighlight %}

<p>Then use it in streams:</p>

{% highlight clj %}
(streams
  (tagged \"latency\" (librato :gauge)))
{% endhighlight %}

<p>You can submit events as annotations too. See the <a href="api/riemann.librato.html#var-librato-metrics">librato-metrics documentation</a>.</p>

<h3>Notify with Pagerduty</h3>

<p>Create a client with your pagerduty service key, then use <code>:trigger</code> and <code>:resolve</code> to open and close issues for a given host and service:</p>

{% highlight clj %}
(let [pd (pagerduty "my-service-key")]
  (streams
    (changed-state
      (where (state "ok")
        (:resolve pd)
        (else (:trigger pd))))))
{% endhighlight %}

<h3>Forward between Riemann servers</h3>

<p>When you have *many* events, you can use multiple Riemann servers to scale
out. You might, for instance, run one Riemann server per datacenter, and
forward only state changes in each service to a master server for a birds-eye
view.</p>

{% highlight clj %}
(streams
  (let [client (tcp-client :host "aggregator")]
    (by [:host :service]
       (changed :state
                (forward client)))))
{% endhighlight %}


<h2>Contributing to Riemann</h2>

<h3>Write a client</h3>

<p>A TCP connection to Riemann is a stream of messages. Each message is a 4
byte network-endian integer *length*, followed by a Protocol Buffer Message of
*length* bytes. See the <a
  href="https://github.com/aphyr/riemann-java-client/blob/master/src/main/proto/riemann/proto.proto">protocol
  buffer definition</a> for the details.</p>

<p>Over UDP, the length header is omitted; just send the protobuf Message
directly. UDP datagrams have a default maximum size of 16384 bytes by
Riemann's default; larger messages should go over TCP. This limit is
configurable in both the client and server; client values *must* be smaller
than the server's.</p>

<p>The server will accept a repeated list of Events, and respond with a
confirmation message with either an acknowledgement or an error. Check the `ok`
boolean in the message; if false, message.error will be a descriptive
string.</p>

<p>Because protocol buffers is strongly typed, the metric of an event is
represented as one of metric_d (floating point 64-bit), metric_f (floating
point 32-bit), or metric_sint64 (64-bit signed integer). Your client should emit
and consume all of these types. For compatibility with older versions of
Riemann, you may *also* emit a metric_f alongside the normal type; newer
versions of Riemann will prefer the higher-resolution types.</p>

<p>Events are uniquely identified by host and service. Both allow null.
Event.time is the time in unix epoch seconds and is optional. The server will
generate a time for each event when received if you do not provide one. I don't
need time resolution finer than 1 second presently, but if you do, my plan is
to add a nanosecond field as well.</p>

<p>You can also query events from the index using a basic query language. Just
submit a Message with your query in message.query.string. Search queries will
return a message with repeated Events matching that expression. A null
expression will return no states. For some example queries, see <a
  href="https://github.com/aphyr/riemann/blob/master/test/riemann/test/query.clj">The
  query test suite</a>.</p>

<p>You might find it useful to read the <a
  href="https://github.com/aphyr/riemann-ruby-client">Ruby client</a> source as
a guide to writing your own client.</p>

<h3>Work with the Riemann source</h3>

<p>I try to keep master as clean and runnable as possible. Riemann has an
exhaustive test suite, which helps ensure code quality. If you plan on changing
the Riemann source, fork it on Github so you'll be able to send pull requests
quickly. If you just want to run the latest version, go ahead and clone the
official repo:</p>

{% highlight sh %}
git clone git://github.com/aphyr/riemann.git
cd riemann
{% endhighlight %}

<p>You'll also need a JVM, and <a
  href="https://github.com/technomancy/leiningen">leiningen 2</a>--the Clojure
build system.</p>

<p>To run the tests suite, try <code>lein test</code>. To start Riemann, run
<code>lein run</code>. Riemann will read the file <code>riemann.config</code>
in the current directory. If you want to run a different config file, try</p>

{% highlight sh %} lein run -- path/to/my/riemann.config {% endhighlight %}

<p>If you want a fat jar, run <code>lein uberjar</code> and copy
target/riemann-{version}-STANDALONE.jar. To build tarball and debian packages,
use <code>lein pkg</code>; .debs and .tar.gz files, plus md5sums, will appear
in <code>target/</code>.

<p>The protocol buffer codec and clojure client live in <a
  href="https://github.com/aphyr/riemann-clojure-client">riemann-clojure-client</a>,
which wraps the java protobuf code and java client in <a
  href="https://github.com/aphyr/riemann-java-client">riemann-java-client</a>.
Both of these are available on clojars and most of the time you can ignore
them. However, if you need to change the protocol or client, you can fork these
projects and make your changes there.</p>

<h3>Building riemann-java-client</h3>

<p>You'll need maven, and the protocol buffers compiler (protoc) version
2.4.1.</p>

<p>When you've made changes to the java client, install it with <code>mvn
  install</code>; then test the clojure client and install it with <code>lein
  install</code>. Finally, you can run riemann itself. You may need to check
that the client versions you're working with match up in the riemann and
riemann-clojure-clientproject.clj files.</p>

<h3>Fix a bug or add a feature</h3>

<p>First, <a href="https://github.com/aphyr/riemann">fork Riemann on
  github</a>. Clone your fork and create a new topic branch for your fix:</p>

{% highlight sh %}
git clone git@github.com:your-github-username/riemann.git
cd riemann
git checkout -b fix-some-bug
{% endhighlight %}

<p>Most of Riemann's source lives in <code>src/riemann/</code>. Corresponding
tests live in <code>test/riemann/test/</code>. When you fix a bug or add a
feature, make sure to add new tests that confirm its correctness! You can run
the test suite with</p>

{% highlight sh %}
lein test
{% endhighlight %}

<p>Some tests for integrating with other services require a local sendmail, or
graphite, or credentials for a web service. If you make changes that affect
these systems, you can test them with special selectors like <code>lein test
  :graphite</code> or <code>lein test :email</code>. If you're working with a
particular namespace, like <code>riemann.streams</code>, <code>lein test
  riemann.test.streams</code> runs only the tests for that namespace. Once your
tests pass, commit your changes and push them to github:</p>

{% highlight sh %}
git commit -a
git push origin fix-some-bug
{% endhighlight %}

<p>If you change more than a few lines of whitespace, please make your
formatting changes in a separate commit; it'll be easier for me to read and
understand your changes. Please try to send me only a few commits where
possible; use <code>rebase --interactive</code> to squash your small
changes.</p>

<h3>Help write documentation</h3>

<p>Riemann's web site and documentation are in the gh-pages branch of the
riemann repository. <a href="https://github.com/aphyr/riemann">Fork riemann on
  github</a>, clone your fork, and check out the branch:</p>

{% highlight sh %}
git clone git@github.com:your-github-username/riemann.git
cd riemann
git checkout gh-pages
vim howto.html
{% endhighlight %}

<p>Pages are built with Jekyll. To see how your changes will appear on the site,</p>

{% highlight sh %}
sudo apt-get install python-pygments jekyll
cd riemann
jekyll
{% endhighlight %}

<p>... and open _site/howto.html in a web browser. When you're satisfied with
your changes, commit, push, and send me a pull request:</p>

{% highlight sh %}
git commit -am "Added a howto guide for integrating with FooService"
git push
{% endhighlight %}

    </div>
  </div>
</div>
