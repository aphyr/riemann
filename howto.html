---
title: Riemann - Howto
layout: default
---

<style>
  body {
    background: #ff9000; /* Old browsers */
    background: -moz-radial-gradient(center, ellipse cover,  #ff9000 0%, #d14c00 100%); /* FF3.6+ */
    background: -webkit-gradient(radial, center center, 0px, center center, 100%, color-stop(0%,#ff9000), color-stop(100%,#d14c00)); /* Chrome,Safari4+ */
    background: -webkit-radial-gradient(center, ellipse cover,  #ff9000 0%,#d14c00 100%); /* Chrome10+,Safari5.1+ */
    background: -o-radial-gradient(center, ellipse cover,  #ff9000 0%,#d14c00 100%); /* Opera 12+ */
    background: -ms-radial-gradient(center, ellipse cover,  #ff9000 0%,#d14c00 100%); /* IE10+ */
    background: radial-gradient(ellipse at center,  #ff9000 0%,#d14c00 100%); /* W3C */
    filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#ff9000', endColorstr='#d14c00',GradientType=1 ); /* IE6-9 fallback on horizontal gradient */
  }
</style>

<div class="row">
  <h1 class="twelvecol">A <span class="focus">guide</span> to working with Riemann</h1>
</div>

<div class="row">
  <div class="sixcol">
    <p>This is not a comprehensive guide to everything in Riemann, but it can
    get you started and help solve specific problems. Want to add your own
    article to this page? <a href="#help-write-documentation">Send me a pull
      request!</a></p>
  </div>

  <div class="sixcol last">
    <p>Once you know where to look, you can learn more by reading the <a
      href="api">API docs</a> (especially <a
      href="api/riemann.streams.html">riemann.streams</a>), and <a
      href="https://github.com/aphyr/riemann/tree/master/src/riemann">the
      source</a>.  I try hard to write readable code. The <a
      href="https://github.com/aphyr/riemann/tree/master/test/riemann">test
      suite</a> is also a great place to look for use examples.</p>
  </div>
</div>

</div><!-- container -->
<div class="light">

<div class="container">

  <script type="text/javascript" charset="utf-8">
    $(document).ready(function() {
      $("#toc").tableOfContents(null, {
        startLevel: 2,
        depth: 2,
        topLinks: true
      });
    });
  </script>

  <div class="row">
    <div class="twelvecol">
      <div id="toc">
      </div>
    </div>
  </div>

  <div class="row">
    <div class="twelvecol">

<h2>Running Riemann</h2>

<div class="row">
  <div class="sixcol">
    <h3>Changing the config</h3>
    <p>If you use the Debian or Centos packages, Riemann adds a
    <code>riemann</code> user, stores its configuration in
    <code>/etc/riemann/riemann.config</code>, and logs to
    <code>/var/log/riemann.log</code>. You should always tail the log file when
    working with Riemann; it'll alert you to configuration errors and help you
    debug your streams.</p>
  </div>
  <div class="sixcol last">
{% highlight sh %}
tail -F /var/log/riemann.log
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>In another terminal, use your favorite editor to open
    <code>/etc/riemann/riemann.config</code>. Let's add a logging stream, so we
    can see all events that pass through the streams. <code>#(info %)</code>
    expands into <code>(fn [x] (info x))</code>, which is a function that takes
    an event and logs it at the INFO log level.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(streams
  index
  ...
  #(info "received event" %))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Now we need to reload the config file. Riemann will respond to SIGHUP,
    or you can use the init scripts. You'll see a message about reloading the
    config in the Riemann log. If you make a mistake, like a syntax error,
    Riemann will continue running with the old config and won't apply the new
    one. Instead, it'll log an explanation of the problem, so you can
    investigate and fix it.</p>

    <p>Now that the config has been reloaded, you should see events flowing by
    in the log. Some come from external sources, like riemann-health or your
    own programs. Others are generated by Riemann internally, as a part of its
    internal performance instrumentation. You can insert logging statements
    anywhere in your streams to verify what kind of events are flowing through
    that point.</p>

    <p>Reloading is experimental, and is subject to the normal Clojure rules
    about <code>(def)</code> and <code>(defn)</code>. To avoid confusion, use
    <code>let</code> bindings instead of <code>def</code>; it'll guarantee
    reloads work correctly. If reloads seem broken, you might need to do a
    full restart for your changes to take effect.</p>
  </div>

  <div class="sixcol last">
{% highlight sh %}
sudo service riemann reload
{% endhighlight %}
  </div>
</div>

<h3>Putting Riemann into production</h3>
<div class="row">
  <div class="sixcol">
    <p>Riemann has three main parts: clients, the server, and dashboard. By
    default, all listen on the loopback interface. You'll need to configure
    each to listen to an appropriate interface for your environment. On the
    host that runs the Riemann server, open
    <code>/etc/riemann/riemann.config</code>, and change the host that Riemann
    binds to. To listen on all interfaces, use <code>0.0.0.0</code>.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(let [host "0.0.0.0"]
  (tcp-server {:host host})
  (udp-server {:host host})
  (ws-server  {:host host}))
{% endhighlight %}
  </div>
</div>
<div class="row">
  <div class="sixcol">
    <p>Now we need to reload Riemann to tell it about our changes.</p>
  </div>
  <div class="sixcol last">
{% highlight sh %}
sudo service riemann reload
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>To change the address that the dashboard binds to, see <a href="https://github.com/aphyr/riemann-dash">riemann-dash's README</a>.</p>
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Riemann-dash only serves some JS code and a small piece of
    configuration; the browser connects directly to Riemann's websocket server
    to receive events. To connect the dashboard to a remote Riemann server,
    double-click the text box in the top right of the dashboard, and change the
    address from <code>127.0.0.1:5556</code> to your Riemann server's host and
    port. When you hit enter, the browser will initiate a websocket connection
    to that address and begin displaying events. Hit <code>s</code> to save the
    new dash config; the dashboard will connect to that address every time you
    load the page.</p>

    <p>If the dashboard is unable to connect to the Riemann websocket server,
    you'll see an alert pop up every few seconds. Check that the server is
    running, that the Riemann websocket server is reachable from your browser,
    that you used the correct host and port, and so on.<p>

    <p>If you don't see *anything* on the dash, but it connected successfully,
    you may not have any events to show, or you may not have set up any
    views.</p>
  </div>
</div>

<div class="row">
  <h3>Change the log file</h3>

  <div class="sixcol">
    <p>To log to a file, just say</p>

{% highlight clj %}
(logging/init {:file "/path/to/some/riemann.log"})
{% endhighlight %}

    <p>If you'd prefer to only log to the console, just leave out :file</p>

{% highlight clj %}
(logging/init)
{% endhighlight %}
  </div>
</div>

<div class="row">
<h3>Overriding Riemann functions</h3>

<div class="sixcol">
  <p>Sometimes, something in Riemann doesn't work the way you'd like. When this
  happens, you can redefine any function in Riemann in the config file. Just
  switch to the appropriate namespace, redefine the function, and switch back to
  <code>riemann.config</code>.</p>

  <p>For instance, let's say you wanted to change how emails are formatted. The
  namespace <code>riemann.common</code> has a function called <code>body</code>,
  which accepts a sequence of events and returns a string. We'll override it in
  our config file:</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(ns riemann.common)
(defn body [events]
  ; pr-str formats events as a clojure-readable string.
  (pr-str events))
(ns riemann.config)

; And then your servers, streams, etc...
(tcp-server ...)
(streams ...)
{% endhighlight %}
  </div>
</div>

<h3>Fault tolerance</h3>

<div class="row">
  <div class="sixcol">
    <p>Because Riemann performs arbitrary computation over the event stream,
    with side effects, it <i>cannot</i> be distributed safely. You can,
    however, distribute it somewhat less than safely--a technique aligned with
    Riemann's philosophy that "mostly correct information <i>right now</i> is
    more useful, than totally correct information only available once the
    failure is over."</p>

    <p>One obvious distribution strategy is to place two Riemann nodes on the
    same switch and have them share a virtual IP address using, say, Heartbeat
    or Corosync. On resource acquisition, the node allocating the IP should
    issue a gratuitous arp broadcast over that interface advertising the new
    route to the relevant switch(es). Failover in this case looks essentially
    like restarting a Riemann node, which should be relatively painless--most
    Riemann deployments fill in missing state within a few seconds to
    minutes.</p>

    <p>What happens if the nodes are isolated by a network partition and both
    claim the interface? Depends on your network, but the answer is "probably
    not good things". OTOH, there's no good way for *any* consensus algorithm
    in an asynchronous network to make latency-bounded decisions in a safe way.
    FLP rears its ugly head. You're going to lose data in the short term; the
    question is how to emit as much useful, actionable information as possible,
    so you can fix the problem.</p>

    <p>I've got a sketch worked out for a highly-available clustered Riemann
    which tries to negotiate these tradeoffs in a sane way, but it involves
    minimum latency costs, severe throughput costs (I'm estimating three to
    five orders of magnitude slower), disk IO, all kinds of esoteric failure
    modes, and some moderately challenging mathematics. It'd take a long time
    to build and would require some serious educational work on my part.
    There's just no way around it: distributing arbitrary latency-bounded
    computation is hard. You're going to have to reason about consensus. I'm
    really sorry about this. :(</p>
  </div>
</div>

<h3>Sharding</h3>

<div class="row">
  <div class="sixcol">
    <p>Because Riemann performs arbitrary computation, it can't shard your
    workload automatically. You'll need to pick some axes along which to shard,
    perform local aggregation on those nodes, and reduce the results with some
    higher-level Riemann node. The <code>forward</code> stream can help you
    connect nodes to one another, and <code>async-queue!</code> can allow some
    elasticity around latency jitters and downstream node restarts, but the
    actual sharding and discovery mechanics you'll have to build yourself.</p>
  </div>
</div>

<h3>Client backpressure, latency, and queues</h3>

<div class="row">
  <div class="sixcol">
    <p>Event processing in Riemann's model is synchronous (though there's lots
    of asynchronous stuff going on internally). When you send an event to
    Riemann, it flows through every top-level stream, and possibly those
    streams children, and *their* children, and so forth. Once the event has
    flowed through every stream, Riemann sends an acknowledgement back to the
    client. This model enables *backpressure*: clients can use the
    acknowledgements to avoid overwhelming Riemann with more events than it can
    process.</p>

    <p>Riemann keeps track of some internal metrics, exposed as events, for
    stream latency and TCP server latency. Stream latency is how long it took
    for an event to flow through every stream. Server latency is how long it
    took for an event to be picked up by Riemann's TCP server, decoded, handed
    off to the streaming system, processed, and for the acknowledgement to be
    sent back to the client.</p>

    <p>If you wait for an acknowledgement every time you send a message to
    Riemann, each process will behave synchronously. This approach is just fine
    when there are lots of clients sending requests infrequently, where
    "infrequently" means, via Little's Law, that the typical period between
    events is greater than the tcp server latency plus the round-trip network
    time to Riemann itself.</p>

    <p>Sometimes, though, you'll want to send events *faster* than that. You've
    got a few options here.</p>

    <p>If you ignore the acknowledgement messages, you can just shove events at
    Riemann as fast as your runtime will let you. Those events will fill up a
    queue in front of Riemann's streaming system. If that fills up, they'll
    spill over into the Netty queue associated with the channel. If that fills
    up, they'll spill over into the TCP buffer on the Riemann box, and by
    extension, the queues in the network and the sending node. At some point
    TCP backpressure will come into play, but understanding that interaction
    can be complex.</p>

    <p>Doing this kind of infinitely-asynchronous send will manifest as high
    memory consumption on the Riemann node (to store all those queued
    operations), and correspondingly high wait times for events. If events
    arrive *too* far delayed, they may no longer be valid by the time they
    arrive, and you'll start seeing services expire. It's like sending a
    message via a courier who gets stuck in a waiting room and dies en
    route.</p>

    <p>You can detect this (and alert on it) by watching the service called
    "riemann netty execution-handler queue size"; if it starts getting above a
    thousand events or so, you're likely overloading Riemann. This queue size
    is directly related to the latency distribution given by "riemann streams
    latency 0.5" and friends, and "riemann streams rate". The higher the
    latency, and the higher the throughput, the larger the queue.</p>

    <p>So: infinite asynchrony is a problem. You want *some* degree of
    asynchrony, especially when Riemann processes faster than the time it takes
    to send events over the network. But too much and you'll crash into finite
    resource limits. We need *backpressure*: bounds on the number of
    outstanding asynchronous requests, or the rate at which we send them.</p>

    <p>One option is simply to spin up more threads and have each send
    synchronously.  Depending on the client's design, you may be able to have
    many threads concurrently sending operations over the same connection.
    Riemann-java-client and riemann-clojure-client, for instance, will
    interleave operations from multiple threads on a single network connection.
    If threads are cheap in your runtime, or you don't need very many (on the
    JVM, more than 10K IO threads is probably a warning sign), this is
    perfectly fine. If you're running in Erlang or Haskell, threads are dirt
    cheap; fire away.</p>

    <p>If threads in your runtime are more expensive, or you don't have them at
    all--say, node.js--you can emulate them using other asynchronous
    constructs.  Riemann-java-client and riemann-clojure-client, for instance,
    have async-send functions that return promises; you can dereference those
    promises to find out whether Riemann acknowledged the message. Deref'ing
    blocks until acknowledgement occurs, or throws an exception if something in
    the network or Riemann went wrong. You can specify a timeout for deref; if
    the timeout is zero, you get a nonblocking check ("did it go through
    yet?"). Fixed timeouts are useful for retries of idempotent operations.
    "Allow this much time, then send again". Same semantics as any other
    asynchronous or stateful construct in Clojure.</p>

    <p>The important thing for *backpressure*, if you're emulating threads
    using asynchronous objects, coroutines, continuations, fibers, callbacks,
    or what-have-you, is that you a.) eventually dereference the results of the
    send, and b.) only allow a fixed number of outstanding asynchronous
    requests.  Riemann-java-client automatically throws (or returns promises
    which throw) when you try to send more than a few thousand concurrent
    messages, forcing you to implement backpressure and flow control logic. You
    can tune this option if you like, but it's there to protect you against
    unbounded resource consumption on either Riemann's side or the client.</p>

    <p>Different clients and different languages will expose these constructs
    in different ways, but you'll find the same core ideas of limited
    asynchrony, queuing, and backpressure in every networked system.</p>
  </div>
</div>

<h2>Debugging</h2>

<h3>Printing events to the console or log</h3>

<div class="row">
  <div class="sixcol">
    <p>Streams are just functions, so you can use any function that prints an
    event to the console to see which events pass through a particular stream.
    <code>prn</code> prints an object to the console, so adding
    <code>prn</code> to any stream prints the events at that stream to the
    console.</p>

    <p>If you want to log to the logfile and/or console log, use <code>#(info
      %)</code>, which is a shorthand for the anonymous function <code>(fn [x]
    (info x))</code>. Note that <code>info</code> logs events a little
  differently than <code>prn</code>, but you can use <code>pr-str</code> to
  recover the clojure representation if desired.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(streams
  (where (service "bar")
    ; Print event to console
    prn

    ; Print :foo, then the event
    #(prn :foo %)

    ; Log event to the console
    #(info %)

    ; Log event using the same representation as prn
    #(info (pr-str %))

    ; Log some specific fields
    #(info (:service %) (:metric %))
{% endhighlight %}
  </div>
</div>

<h3>Troubleshooting missing events</h3>

<div class="row">
  <div class="sixcol">
    <p>First, determine whether the events you're looking for are actually
    making it into Riemann. This will help localize the problem to the
    <i>network</i> or the <i>streams</i>. Add a new top-level stream which
    simply logs all inbound events. Use a <code>(where)</code> filter around
    that logging stream to cut down on noise.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(streams
  #(info %))
{% endhighlight %}

{% highlight clj %}
(streams
  (where (service "some thing you're looking for")
    #(info %)))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>If you don't see the events you're looking for in the logs, they must
    be dropped <i>before</i> arriving at the streaming system. Check:</p>

    <ul>
      <li>Riemann clients are sending to the correct Riemann host and port.</li>
      <li>Riemann is listening to that host and port. Check <code>(tcp-server)</code> and <code>netstat -lntp | grep riemann</code>.</li>
      <li>The network can relay packets from the client machine to the Riemann
      server. Use <code>telnet some.host 5555</code> or <code>nmap -sT
        some.host -P 5555</code>.</li>
      <li>Your packets are making it from the client to the server. UDP
      messages can be dropped, delayed, duplicated, or re-ordered at any time
      by the network, or discarded if the receiving node's receive buffer is
      too full. Try using TCP.</li>
    </ul>
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>If your messages <i>are</i> arriving in the streaming system, but aren't
    making it to the index or other output streams, gradually slide the
    <code>#(info %)</code> stream downstream towards the exit point, to verify
    at which point in the chain the events are not what you expect.</p>

    <p>If you're indexing events, but they don't appear in queries, they may
    have expired from the index. Try <code>(expired #(warn "expired" %))</code>
    to warn about expired events. They may be expiring because their TTL is
    shorter than the interval between events. They may also expire because the
    Riemann clock is in the future relative to the originating event, due to
    clock skew or network/processing latency.</p>

    <p>Check the internal instrumentation for the Riemann queue depth and core
    latencies; if the queue is more than a handful of events deep, or stream
    latencies are on the order of the relevant event TTLs, you might need to
    reduce the load on the Riemann server or investigate downstream services
    that might be slow.</p>

    <p>Check clock skew between nodes using <code>watch date</code> or similar.
    Make sure your clocks are in UTC, <i>not</i> local time. Never local time.
    <i>Especially</i> never Daylight Savings Time. You can use Riemann's
    <code>clock-skew</code> stream to measure clock skew as seen by the Riemann
    node as well.</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(streams
  #(info %) ; First, measure here
  (where (service #"^riak .+")
    #(info %) ; Then move the info stream here to check the filter
    (by :service
      (coalesce
        #(info %) ; Third, check the coalesced vector of events
        (smap folds/maximum
          #(info %) ; Fourth, probe here to check the maximum calculation
          (with :host nil
            #(info %) ; Finally, check exactly what events are being applied
                      ; to the index.
            index))))))
{% endhighlight %}
  </div>
</div>

<h3>Connecting to the REPL</h3>

<div class="row">
  <div class="sixcol">
    <p>Riemann has an nREPL server built in. You can enable this in your config
    with:</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(repl-server {:host "127.0.0.1"})
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>You can then use Leiningen 2 to connect to it.</p>
  </div>
  <div class="sixcol last">
{% highlight sh %}
git clone git://github.com/aphyr/riemann.git
cd riemann
lein repl :connect 127.0.0.1:5557
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>You can reload the config by sending Riemann a SIGHUP, but you can also
    do it from the REPL.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
user=> (riemann.bin/reload!)
{% endhighlight %}
  </div>
</div>


<h2>Instrumenting your systems</h2>

<h3>Measure Riemann itself</h3>

<div class="row">
  <div class="sixcol">
    <p>Riemann comes with instrumentation built-in, which is sampled
    periodically and injected into the event stream. You can query the
    dashboard for <code>service =~ "riemann %"</code> to see Riemann's internal
    metrics. All latencies are in milliseconds.</p>

    <p><code>riemann streams</code> refers to the stream processor: its
    throughput measures the number of events being passed to <code>(streams
      ...)</code> per second, and its latencies indicate the time it takes to
    process a single event through the streaming system.</p>

    <p>The TCP, UDP, and Websockets servers instrument their throughput and
    latency where possible. TCP latency measures the time from initial message
    deframing to Netty write of the corresponding response. For instance,
    <code>riemann server tcp 1.2.3.4:5555 in latency 0.95</code> measures the
    95th percentile time, in milliseconds, for the TCP server on port 5555 to
    parse, queue, process, and dispatch a response for a message.  The rate for
    servers measures *message* rate, not *event* rate.</p>

    <p>The main queue connecting Netty IO threads to the parsing/execution
    threadpool is measured by <code>riemann netty execution-handler queue
    size</code>, and is a critical measure of whether the streaming system is
  overloaded relative to inbound request load.</p>

    <p>To disable instrumentation, or control how often events are sampled, see
    <a
      href="http://riemann.io/api/riemann.config.html#var-instrumentation">riemann.config/instrumentation</a>.</p>
  </div>
</div>

<h3>Measure CPU, memory, and disk use</h3>

<div class="row">
  <div class="sixcol">
    <p><a href="https://github.com/aphyr/riemann-tools">Riemann-tools</a>
    includes a program called riemann-health, which measures the local host's
    cpu, memory, and disk use. You can install it from rubygems.</p>
  </div>
  <div class="sixcol last">
{% highlight sh %}
gem install riemann-tools
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>... and run riemann-health with the address of your riemann server like
    so:</p>
  </div>
  <div class="sixcol last">
{% highlight sh %}
riemann-health --host 1.2.3.4
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Riemann-health reports utilization <i>fractions</i> by default, ranging
    from zero to one. Load average is divided by the number of cores, and disk
    use by capacity. You can adjust the polling interval, what percentage of
    cpu use is considered critical, and more. <code>riemann-health
    --help</code> will tell you more.</p>
  </div>
</div>

<h3>Monitor Riak</h3>

<div class="row">
  <div class="sixcol">
    <p><a href="https://github.com/aphyr/riemann-tools">Riemann-tools</a>
    includes riemann-riak, which uses riak's HTTP stats interface, some
    filesystem checks, and optionally, some erlang RPC requests to measure
    Riak's get and put latencies, request throughput, ring status, and disk
    use. Run riemann-riak on each Riak node.</p>

    <p>Riemann-riak comes with defaults for the riak .deb packages shipped by
    Basho, but it's tunable for other configurations. See <code>riemann-riak
    --help</code> for more options.</p>
  </div>
  <div class="sixcol last">
    {% highlight sh %}
    gem install riemann-tools
    riemann-riak --host 1.2.3.4
    {% endhighlight %}
  </div>
</div>

<h3>Custom event attributes</h3>

<div class="row">
  <div class="sixcol">
    <p>You can include arbitrary additional fields in Riemann
    events. These are not a replacement for service, host, and time: the
    composite primary key of a logical "thing" in the Riemann universe, but
    they *do* let you more easily aggregate and filter events, or carry richer
    contextual information associated with a single message.</p>
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>In most clients you can simply pass an extra key and value in the event
    map. In strongly-typed clients like riemann-java-client, special methods
    like EventDSL.attribute(key, value) are present.</p>
  </div>

  <div class="sixcol last">
{% highlight rb %}
client << {service: "thumbnailer rate",
           metric:  5.0,
           build:   "7543"}
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Custom attributes are always encoded as strings in Protocol Buffers
    (pull request welcome!), but you can replace them with parsed variants in
    your streams using smap, adjust, and friends.</p>

    <p>In the Riemann server, custom attributes work just like normal
    attributes on events--they're just a bit slower, owing to the hashmap
    lookup. Just like normal fields, you can use get, assoc, dissoc, update,
    and all the other Clojure functions over maps. Custom attributes do *not*
    have shorthand syntax in <code>(where)</code> (to prevent arbitrary symbol
    capture), but are accessible through <code>(:my-field event)</code>.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (service "thumbnailer rate")
  ; Convert build numbers from strings to longs
  (adjust [:build #(Long. %)]
    ; Compute a throughput for each specific build
    (by :build
      (smap #(assoc % :service (str (:service %) " build " (:build %)))
        (rate 5 index)))

    ; Or maybe an old version reported numbers that were 2x larger than they
    ; should have been
    (where (< (:build event) 1055)
      (scale 1/2 index)
      (else index))))
{% endhighlight %}
  </div>
</div>

</div>

<h2>Working with streams</h2>

<h3>Split streams</h3>

<div class="row">
  <div class="sixcol">
    <p>Splitting streams is the default in Riemann. Almost all streams, unless
    otherwise documented, take any number of child streams as their final
    arguments, and forward the same events on to all of them.  Because Riemann
    uses Clojure's immutable data structures, you don't have to worry about
    locking or mutation. Streams "change" events by sending altered,
    shared-structure *copies* of events downstream. For instance, this where
    expression sends matching events to <i>two</i> child streams; one of which
    indexes a copy of the event with service "foo", and the other with service
    "bar".</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (host "db04")
  (with :service "foo" index)
  (with :service "bar" index))
{% endhighlight %}
  </div>
</div>

<h3>Combine streams</h3>

<div class="row">
  <div class="sixcol">
    <p>Sending events from two places to the same stream is simple: just bind
    the stream to a variable. In Clojure, <code>(let [x 1 y 2] ...)</code>
    assigns <code>x</code> to <code>1</code> and <code>y</code> to
    <code>2</code> everywhere inside the <code>let</code> expression. Since
    streams are values, you can bind them to variables too. For instance, this
    code has two paths--one for http and one for 0mq--which flow into the same
    rate stream, and from there to the index.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(let [index (index)
      ; every 5s, aggregate everything submitted to this stream and forward
      ; the result to the index
      aggregate (rate 5
        (with :service "aggregated req rate" index))]

  (streams
    (where (service "http req rate")
      index      ; save the individual value to the index
      aggregate) ; and also submit it for aggregation

    (where (service "0mq req rate")
      index                  ; save the individual value to the index
      (scale 2 aggregate)))) ; and submit the doubled value for aggregation
{% endhighlight %}
  </div>
</div>

<h3>Distinct streams for each host, service, etc.</h3>

<div class="row">
  <div class="sixcol">
    <p>Often, you want to run *many copies* of a particular stream; say,
    computing a rate for each service separately, or each [host, service] pair.
    Use <code>by</code> to bifurcate a stream into distinct copies based on a
    function or vector of functions of that event. For instance, to sum up disk
    use across hosts, but retaining a distinct sum for each service, you could
    write:</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(by :service
  (coalesce
    (smap folds/sum
      (with :host nil
        index))))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Or to compute a rate for each distinct host and service:
  </div>
  <div class="sixcol last">
{% highlight clj %}
(by [:host :service]
  (rate 5 index))
{% endhighlight %}
  </div>
</div>

<h3>Filter events</h3>

<div class="row">
  <div class="sixcol">
    <p>Often, we want to do some operation only on a subset of events flowing
    through a stream. For instance, we might only want to email events which
    have the state "error". The basic filtering streams are <a
    href="api/riemann.streams.html#var-where">where</a>, her less magical
    sister <a href="api/riemann.streams.html#var-where*">where*</a>, <a
      href="api/riemann.streams.html#var-match">match</a>, <a
      href="api/riemann.streams.html#var-tagged-all">tagged-all</a> and <a
      href="api/riemann.streams.html#var-tagged-any">tagged-any</a>, and <a
      href="api/riemann.streams.html#var-expired">expired</a>. Most of the
    time, you'll use <code>where</code>.</p>
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Where takes a <i>predicate</i>, which is a special expression for
    matching events. After the predicate, <code>where</code> takes any number
    of child streams, each of which will receive events which the predicate
    matched. For example, we could email only events which have state
    "error".</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(streams
  (where (state "error")
    ; Only events which have the state "error" are passed on to the email
    ; stream:
    (email "delacroix@vonbraun.com")))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Where expressions can match particular values of a field; like passing
    on events which occur only on the Von Braun:</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (host "von braun") ...)
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Regular expressions (in Clojure, strings like <code>#"foo .+"</code>) can be used to match fields as well.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (description #"an+elids") ...)
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>You can filter for the presence of a given tag.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (tagged "mutant") ...)
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>There are also streams specifically for selecting events which have
    some, or all, of a set of tags. Tagged is shorthand for tagged-all.</p>

  </div>
  <div class="sixcol last">
{% highlight clj %}
(tagged-any ["cat" "dog"] (with :service "animals/sec" (rate 1 index)))
(tagged-all ["ops" "ddos"] (email "ops@githug.com"))

(tagged "page" page-ops)
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Numeric functions work like you'd expect:</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(where (>= (* metric 1000) 2.5))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Which makes range queries easy:</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (< 5 metric 10))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Predicates can use any function or macro, including boolean operators.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (not (or (tagged "www")
                (and (state "ok") (nil? metric)))))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>You can also define and use arbitrary functions in your predicates.
    (where) binds the variable <code>event</code> to the event being
    considered.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(defn global? [event] (nil? (:host event)))
(where (global? event))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Higher-order functions work like you'd expect, so you can happily map,
    fold, filter, etc inside a where predicate too. For instance, we can match
    any of several regular expressions:</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (some (fn [r] (re-find r service)) [#"cassandra disk .+"
                                           #"cassandra net .+"
                                           #"cassandra latency \d+"])
  ...)
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Where streams forward an event to their children when the predicate
    matches.  When the predicate *doesn't* match, where will forward events to
    any children in an <code>(else)</code> block.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (or (service "ok") (service "warning"))
  index
  (else
    (email "ops@foo.com")))
{% endhighlight %}
  </div>
</div>

<h3>Set thresholds</h3>

<p>You can use (where) to alert you when a metric goes out of bounds. Where the
metric falls between zero and five, inclusive, index it with state "ok".
Otherwise, index it with "warning":</p>

{% highlight clj %}
(streams
  (where (<= 0 metric 5)
    (with :state "ok" index)
    (else
      (with :state "warning" index))))
{% endhighlight %}

<h3>Detect state transitions</h3>

<p>The <a href="api/riemann.streams.html#var-changed">changed</a> stream
forwards on events when some fields of that event change. For instance, you
can send an email whenever the state changes:</p>

{% highlight clj %}
(streams
  (by [:host :service]
    (changed :state
      (email "ops@startup.io"))))
{% endhighlight %}

<p>Note that we use <code>(by)</code> so that each distinct host and service
track their changes independently. Otherwise, we'd get alerts when service A
reported "ok" and service B reported "down". There's a shorthand for this:</p>

{% highlight clj %}
(streams
  (changed-state
    (email "ops@startup.io")))
{% endhighlight %}

<p>When you start Riemann, it doesn't know what the previous state was. By
default, <code>changed</code> will forward on the first event it receives. You
can tell <code>changed</code> and <code>changed-state</code> to *assume* an
initial state with the <code>:init</code> option:</p>

{% highlight clj %}
(streams
  (changed-state {:init "ok"}
    (email "ops@startup.io")))
{% endhighlight %}

<p>I tend to include this snippet in my riemann configurations so I can keep
track of which services are starting, crashing, and gracefully restarting.</p>

<h3>Measure your app's latency profile</h3>

{% highlight clj %}
; Imagine you wanted to know the time it takes for your app's API requests
; to complete. The API emits events like:
;
; {:service "api req"
;  :metric: 0.240} ; 240 milliseconds
;
; So first, we select only the API requests

(where (service "api req")

       ; Now, we'll calculate the 50th, 95th, and 99th percentile for all
       ; requests in each 5-second interval.

       (percentiles 5 [0.5 0.95 0.99]

                    ; Percentiles will emit events like
                    ; {:service "api req 0.5" :metric 0.12}
                    ; We'll add them to the index, so they can show up
                    ; on our dashboard.

                    index)

       ; What else can we do with API requests? Let's figure out the total
       ; request rate. (rate interval & children) sums up metrics and
       ; divides by time.

       (rate 5)

       ; But this isn't quite right--these event metrics are *times*, so
       ; we're actually calculating the number of seconds spent by the API,
       ; each second. So we *set* the metric of every event to 1, *then*
       ; take the rate:

       (with :metric 1 (rate 5 index))

       ; (with) takes each event and calls (rate) with a *changed*
       ; copy--one where :metric is always 1. Then (rate) adds up all those
       ; 1's over five seconds, and sends that metric to the index.

       ; (with) has a counterpart, by the way: (default). It works exactly
       ; the same, but it only alters the event when the value is nil. Both
       ; with and default accept maps as well:

       (default {:state "ok" :ttl 60} index)
)))
{% endhighlight %}

<h3>Report exceptions</h3>

<p>Where you handle exceptions in your application, you can also submit an
event to Riemann. I usually set the service to the application name, include
the stacktrace as the description, and tag the event with both "exception" and
the classname of the exception.</p>

{% highlight clj %}
(tagged "exception"
  (email "ops@foocorp.com"))

(tagged-all ["exception" "DatabaseError"]
  (email "db@foocorp.com"))
{% endhighlight %}

<p>It's also easy to track the *rate* of exceptions per second, so you can
graph how many unexpected failures occur per day, and determine which services
need the most attention.</p>

{% highlight clj %}
(where (tagged "exception")
  (with :metric 1
    (by :service
      (adjust [:service str " exception rate"]
        (rate 10 index graph)))))
{% endhighlight %}

<h3>Roll up and throttle events</h3>

<p>Sometimes, when things break, they submit a *ton* of events. Maybe you
receive sixty thousand exceptions in five minutes. You need to know that a
problem exists--but don't need to know about *every single failure*. Riemann
has two streams for controlling the rate of events.</p>

<p><a href="api/riemann.streams.html#var-rollup">rollup</a> will allow a few
events to pass through readily. Then it starts to accumulate events, rolling
them up into a list which is submitted at the end of a given time interval.</p>

<p>Let's define a new stream for alerting the operations team, which sends only
five emails per hour (3600 seconds). We'll receive the first four events
immediately--and at the end of the hour, a single email with a summary of all
the rest.</p>

{% highlight clj %}
(def tell-ops (rollup 5 3600 (email "ops@rickenbacker.mil")))

(streams
  (where (state "error") tell-ops)
  (tagged "exception" tell-ops))
{% endhighlight %}

<p>Rollup holds on to every event, which can use a lot of memory. Sometimes
it's OK to drop some events instead of delivering them. That's where <a
  href="api/riemann.streams.html#var-throttle">throttle</a> comes in: it allows
the first five events through, then ignores all the rest for an hour.</p>

{% highlight clj %}
(def tell-ops (throttle 5 3600 (email "ops@rickenbacker.mil")))
{% endhighlight %}

<p>And naturally, you can combine throttle and rollup to preserve *some*
events, but not allow unbounded memory use:</p>

{% highlight clj %}
(def tell-ops
  (throttle 1000 3600
    (rollup 5 3600
      (email "ops@rickenbacker.mil"))))
{% endhighlight %}

<h3>Detect down services</h3>

<p>Each event has a TTL, which states how many seconds the event is valid for
after its given time. When a service crashes catastrophically, it will stop
submitting events and its events in the index will become stale. Periodically,
the index sweeps out events past their lifetime, deletes them from the index,
and streams an event for that host and service with state "expired".</p>

<p>You can control how often the index scans for expired events with
<code>periodically-expire</code>. Here, we check every ten seconds. If you
*don't* want events to expire from the index, you can delete this line from
your config:</p>

{% highlight clj %}
(periodically-expire 10)
{% endhighlight %}

<p>If events have no TTL given, the index assumes their TTL is 60 seconds. You
can provide a default TTL for any incoming events that don't provide one:</p>

{% highlight clj %}
(streams
  (default :ttl 10
    ; your streams here
    ))
{% endhighlight %}

<p>Now, any services that fail to check in every ten seconds will expire
(unless they give a different TTL). Since expired events have a different
state, any (changed :state) streams will detect the transition and can alert
you:</p>

{% highlight clj %}
(streams
  (changed :state {:init "ok"}
    (email "ops@foo.com")))
{% endhighlight %}

<p>You can also explicitly filter expired events:</p>

{% highlight clj %}
(streams
  ; Email any expired event
  (expired (email "ops@foo.com"))

  ; Process only events which are *not* expired
  (where (not (expired? event))
    ...))
{% endhighlight %}

<p>By default, Riemann copies <code>[:host :service]</code> to expired events.
You can control what keys from events are copied onto expired events by
passing <code>:keep-keys</code> to <code>periodically-expire</code>:</p>

{% highlight clj %}
(periodically-expire 10 {:keep-keys [:host :service :tags]})
{% endhighlight %}

<p>With that in place, you can filter expired events on tags. This way, your app
can decide whether an event is worthy of an alert by tagging it:</p>

{% highlight clj %}
(streams
  (expired
    (tagged "notify-me" (email "ops@foo.com"))))
{% endhighlight %}

<h3>Group events in time</h3>

<div class="row">
  <div class="sixcol">
    <p>Sometimes you want to ask a question about the last few minutes, or of
    groups of 10 consecutive events at a time.</p>

    <ul>
      <li><a href="api/riemann.streams.html#var-moving-time-window">moving-time-window</a> forwards the last n seconds of events</li>
      <li><a href="api/riemann.streams.html#var-moving-event-window">moving-event-window</a> forwards the last n events</li>
      <li><a href="api/riemann.streams.html#var-fixed-time-window">fixed-time-window</a> forwards events from disjoint n-second windows</li>
      <li><a href="api/riemann.streams.html#var-fixed-event-window">fixed-event-window</a> forwards disjoint sequences of n events</li>
    </ul>
  </div>
</div>

<h3>Change units</h3>

<div class="row">
  <div class="sixcol">
    <p>Use the <a href="/api/riemann.streams.html#var-scale">scale</a> stream. For instance, to convert bytes to gigabytes, scale by 1/1024^3.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(scale (/ 1 1024 1024 1024)
  index)
{% endhighlight %}
  </div>
</div>

<h3>Find the host using the most CPU</h3>

<div class="row">
  <div class="sixcol">
    <p>If you're running riemann-health, all hosts will report events like
    <code>{:service "cpu" :host "foo" :metric 0.12}</code>. You want to know
    which host is under the heaviest CPU load. The <code>coalesce</code> stream
    remembers the last events from each host and service, and sends them all as
    a vector to its children. We can map that vector of events to a single
    event--the one with the largest metric--using folds/maximum. Then we just
    set the service and host, since this event pertains to the system as a
    whole.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(coalesce (smap folds/maximum
  (with {:service "Max CPU" :host nil} prn)))
{% endhighlight %}
  </div>
</div>

<h3>Count total number of hosts</h3>

<div class="row">
  <div class="sixcol">
    <p>Sometimes it is useful to know how many hosts are sending data to
    Riemann.  This is especially useful in cloud environments where nodes are
    constantly scaling up and down. We'll assign every event the same service,
    use <code>coalesce</code> to combine the current set of hosts and services
    into a single map, <code>throttle</code> to cut down on the number of
    updates, and <code>folds/count</code> to count the distinct set of hosts.
    Finally we'll strip the host from that event, since it represents a
    property of the entire system, and index it.</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
; All services should be the same
(with :service "distinct hosts"
  ; Combine hosts and services
  (coalesce
    ; Turn lists of events into a single event with the count as its metric
    (smap folds/count
      ; Strip host field
      (with :host nil
        index))))
{% endhighlight %}
  </div>
</div>


<h3>Alerting when a certain percentage of events happen</h3>

<p>Sometimes you'll have a service that will fail. You might expect one or two
failures, but if you get over a certain percentage of failures you want to be
notified. In this case you can use a <code>fixed-time-window</code>.</p>

{% highlight clj %}
(streams
  (where (and (service "signin")
              (not (expired? event)))
    ; We want to get alerted about failed sign ins. However we expect that
    ; there will be failures due to incorect passwords etc. So we only want to
    ; get alerted if more than 50% of the signins in a 60 second period are
    ; failures. Failed signings have state "warning".
    ;
    ; fixed-time-window sends a vector of events out every 60 seconds
    (fixed-time-window 60
      ; smap passes those events into a function
      (smap (fn [events]
        ; Given a list of events, we'll find the number which have state
        ; warning, divide by the total number of events, and emit a new event
        ; based on the ratio.
        (let [fraction (/ (count (filter #(= "warning" (:state %)) events))
                          (count events))]
          ; The metric for this event will be the fraction of failed signins,
          ; and the state will depend on how many failures we see.
          {:service "signin failures"
           :metric  fraction
           :state   (condp < fraction
                      0.7 "critical"
                      0.3 "warning"
                          "ok")}))
        ; Now we can use those "signin failures" events to alert on state
        ; transitions:
        (changed-state (email "ops@trioptimum.com"))))))
{% endhighlight %}

<h3 id="arbitrary-functions-as-streams">Arbitrary functions as streams</h3>
<div class="row">
  <div class="sixcol">
    <p>Since streams are just functions which take an event as their sole
    argument, you can do <i>any</i> computation over events that you like. Just
    write a function, either named or anonymous.</p>

    <p>You can run any Clojure code you like here; using Clojure or Java
    libraries on the classpath, writing to the network, logging to disk, using
    existing variables from the config, and so on. It's up to you.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (service "foo")
  (fn [event]
    ; Log a message
    (info "I got an event:" event)

    ; Then extract some fields and insert them into a DB.
    (save-to-my-database (:description event) (:metric event))))
{% endhighlight clj %}
  </div>
</div>

<h3 id="create-your-own-stream-function">Create your own stream function</h3>

<div class="row">
  <div class="sixcol">
    <p>Riemann builtins like <code>rate</code>, <code>percentiles</code>,
    <code>smap</code>, and so on are all functions which take a variable number
    of child streams and returns a function that takes an event and responds to
    that event. You can build your own stream-generating functions too.</p>
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Let's create a trivial example.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(defn hello-stream [& children]
  (fn [e] (let [new-event (assoc e :hello :world)]
    (call-rescue new-event children))))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Our stream returns a function that when it receives an event, adds a new
    key-pair via <code>assoc</code> and then uses <code>call-rescue</code>, a
    standard library function, to pass the event on to all the child streams it
    was passed.</p>

    <p>Add this new stream to the list of event streams.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(streams (hello-stream prn))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Now when you pass an event into Riemann you should see the event printed
    out with an added key-value pair of <code>:hello :world</code>.</p>

    <p>Streams all essentially work in this way, if you look at the source code
    of the Streams namespace in <code>streams.clj</code>. You can find a few
    simple examples in the functions <code>match</code>, <code>expired</code>,
    <code>under</code> and <code>over</code> which filter whether the event is
    passed along the event stream.</p>
  </div>
</div>

<h3>Reinject events</h3>

<div class="row">
  <div class="sixcol">
    <p>To reinsert an event back into the current core, use
    <code>riemann.config/reinject</code>. Reinjected events flow through all
    top-level streams, just as if they had just arrived from the network. In
    this example, incoming "initial" events are remapped to "derivative"
    events and reinjected into the streaming system. Each event is printed
    twice, first "initial", then "derivative".</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(streams
  (streams/where (service "derivative")
    #(info "derivative" %))
  (streams/where (service "initial")
    #(info "initial" %)
    (streams/with :service "derivative" reinject)))
{% endhighlight %}
  </div>
</div>

<h3>Query the index from within a stream</h3>

<div class="row">
  <div class="sixcol">
    <p>Sometimes, you want the behavior of a stream to depend on the current
    state of the index. Say, for instance, that you wanted to use a
    maintenance-mode service to suppress alerting. To enter maintenance mode,
    we'll submit an event to Riemann which has a TTL as long as the maintenance
    window we want. Here's a ten minute window, sent from a Ruby client:</p>
  </div>
  <div class="sixcol last">
{% highlight rb %}
1.9.3p385 :001 > Riemann::Client.new << {service: "maintenance-mode",
                                         host:    nil,
                                         state:   "active",
                                         ttl:     600}
 => nil
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Next, we'll write a function which identifies whether maintenance mode
    is active. We could use <code>riemann.index/lookup</code> to find a
    particular host/service pair, or <code>riemann.index/search</code> for a
    more general query.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(defn maintenance-mode?
  "Is Riemann currently in maintenance mode?"
  []
  ; Take an expression representing a query for maintenance mode
  (->> '(and (= host nil)
             (= service "maintenance-mode"))
       ; Search the current Riemann core's index for any matching events
       (riemann.index/search (:index @core))
       ; Take the first match
       first
       ; Find its state
       :state
       ; Is it the string "active"?
       (= "active")))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Now we can use that function inside of a where predicate, to pass events
    on only when we're *not* in maintenance mode.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(streams
  (changed-state {:init "ok"}
    (where (not (maintenance-mode?))
      (email "ops@trioptimum.com"))))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Naturally, you could parameterize the maintenance-mode function, perhaps
    taking a host, tag, or service as an argument, and searching for particular
    matching events.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(defn maintenance-mode [host]
  ; Using (list) to build a query dynamically
  (->> (list 'and (list '= 'host host)
                  '(= service "maintenance-mode"))
       ...))

(where (not (maintenance-mode? host))
  (email "ops@trioptimum.com"))))
{% endhighlight %}
  </div>
</div>


<h3>Understanding the Riemann stream model</h3>

<div class="row">
  <div class="sixcol">
    <p>Streams are functions that take an event. There's a subtle distinction
    here: we use the term "stream" to describe both the stream <i>itself</i>,
    but also the functions that <i>generate</i> those streams. Remember, in
    Lisp, <code>(fun arg1 arg2)</code> means "Call <code>fun</code> with
    <code>arg1</code> and <code>arg2</code>".</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
; A function that generates a stream
rate

; Calling the rate function with the arguments `5` and `index`
; returns a stream: a function that accepts events, computes
; a rate every five seconds, and sends rate events to the index.
(rate 5 index)
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Riemann usually calls your streams with events <i>for you</i>. That's
    what the <code>streams</code> function in <code>riemann.config</code>
    means: "here are some functions that you should call when new events
    arrive".</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
; Generate a rate stream, then pass that stream to the `streams` function,
; which tells Riemann to remember that stream and call it with each event as
; an argument.
(streams
  (rate 5 index))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>When a new event arrives, Riemann takes each function you've specified
    using `streams` and calls it with that event. Here's the source of
    <code>riemann.core/stream!</code>.</p>

    <p>That's it. Riemann's entire streaming model is just a function call and
    some careful API design. All the functions in <code>riemann.streams</code>,
    like <code>where</code>, <code>rate</code>, <code>with</code>, etc.  take
    streams as arguments and create new streams which call them, usually
    transforming the events they receive in some way.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(defn stream!
  "Applies an event to the streams in this core."
   [core event]
     (instrumentation/measure-latency (:streaming-metric core)
         (doseq [stream (:streams core))
           (stream event))))
{% endhighlight %}
  </div>
</div>

<h3>Calling streams yourself</h3>

<div class="row">
  <div class="sixcol">
    <p>If you use Riemann's built-in stream-generating functions, you don't
    have to worry about calling streams yourself; Riemann does it for you. But
    sometimes, you want to write your own streams, and will need to call some
    child streams yourself.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (service "cat")
  (fn [event]
    (let [event (assoc event :state "meowing")]
      ; What now???)))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>You might try creating a new stream and calling it with the event, but
    this will probably behave weirdly. In this example, every time a new event
    arrives, we create a <i>fresh</i> rate stream, with completely new state,
    and send our event to it. We probably wanted to send each event to the
    <i>same</i> rate stream.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (service "cat")
  (fn [event]
    (let [event (assoc event :state "meowing")]
      ((rate 5 index) event))))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>If we're writing a new function to generate streams, we might have our
    downstream children passed in as an argument; see any function in <a
    href="https://github.com/aphyr/riemann/blob/master/src/riemann/streams.clj">riemann.streams</a>
  for an example. If we're just defining a one-off stream inline, we can
  <i>bind</i> the child to a variable using <code>let</code>.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (service "cat")
  (let [downstream (rate 5 index)]
    (fn [event]
      (let [event (assoc event :state "meowing")]
        (downstream event)))))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>If we want to call <i>multiple</i> downstream children, use
    <code>sdo</code> to wrap them up into a single stream.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (service "cat")
  (let [downstream (sdo (rate 5 index)
                        prn)]
    (fn [event]
      (let [event (assoc event :state "meowing")]
        (downstream event)))))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Even easier, in this particular case, is to use a general-purpose
    transformation stream like <code>smap</code>.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (service "cat")
  (smap (fn [event]
          (let [event (assoc event :state "meowing")]
            (downstream event)))
    (rate 5 index)
    prn))
{% endhighlight %}
  </div>
</div>

<h3>Generating events from within a stream</h3>
<div class="row">
  <div class="sixcol">
    <p>
    There are times where you will want to generate new events
    from an existing stream. Most of the time, it is preferrable
    to use <code>riemann.streams/with</code> to modifying fields
    from an existing event, but there are cases where it would hinder
    readability or it is just not possible. In that case, use
    <code>riemann.common/event</code>.
    </p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(fixed-time-window 60
  (smap (fn [events]
          (let [errors   (filter (comp #{"warning" "critical"} :state) events)
                fraction (/ (count errors) events)]
            ; Build a new event using a map of fields and values.
            (event {:service "error percent"
                    :metric fraction})))
    index))
{% endhighlight %}
  </div>
</div>

<h3>Asynchronous streams</h3>

<div class="row">
  <div class="sixcol">
    <p>In Riemann, streams are expressed by <i>function composition</i>. Each
    stream is a function that takes an event and does something with it. Child
    streams are just functions too, so when an event propagates through
    different layers of streams, it's actually just a series of function calls.
    We do this for three reasons:</p>

    <ol>
      <li>Locality. When one function calls another, the event remains on the
      stack--which is almost certainly in CPU cache. If streams were
      asynchronous, we'd have to defer the event to some mutable shared state,
      likely somewhere on the heap. That causes contention: the scheduler is,
      to some degree or another, mutable state being accessed by multiple
      threads, which may have to undergo expensive memory-safety operations. We
      also avoid cache stalls in transfering that event and its processing
      context into and out of some scheduler.</li>

      <li>Hotspot. Modern JVMs aggressively optimize function calls via
      inlining, escape analysis, and other techniques. Asynchronous execution
      makes it harder for the JIT to identify optimization opportunities.
      Because stream handoff is cheap in Riemann, we can use <i>lots</i> of
      streams to solve problems instead of worrying about the handoff cost.
      This means that Riemann's API can break problems into smaller, more
      composable pieces.</li>

      <li>Predictability. It's easier to reason about Riemann stacktraces
      because they have the same structure as the source. It's easier to
      predict when side effects will happen. And backpressure is trivially
      built in; no need to reason about concurrency limits for each
      stream.</li>
    </ol>

    <p>In practice, most Riemann streams are pure functions or only mutate
    in-memory state; Riemann is typically <i>cpu-bound</i>. We have a
    threadpool, on the order of num-processors, which runs an event through all
    streams in the core. This makes Riemann quite fast--but when you make a
    blocking call to a downstream service, sometimes the rules change. You
    <i>want</i> additional parallelism for IO, or an explicit queue in between
    two streams. In keeping with the Riemann philosphy of small, re-usable
    components, you can make <i>any</i> stream asynchronous, with its own
    bounded queue, worker threadpool, and performance metrics, via the
    <code>async-queue!</code> stream.</p>
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>For instance, the <code>forward</code> stream forwards events to another
    Riemann server, and returns only when that server has acknowledged the
    message. This provides backpressure and acknowledgement: a client knows
    that its message was accepted not only by the local Riemann server, but also
    by the downstream Riemann server.</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(let [index (index)]
  (streams
    (forward (riemann.client/tcp-client :host "agg.riemann.prod"))
    index))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>But if that link is slow, and we want to return <i>immediately</i>, we
    can defer execution of that stream onto a threadpool via a fixed-size
    queue.  Because we acknowledge before the downstream server acknowledges,
    we might falsely acknowledge a message. The semantics of the stream have
    changed; we're gaining performance and insensitivity to downstream latency,
    but at the cost of safety.</p>

    <p>We <i>bound</i> the number of in-flight operations to the downstream
    service by specifying how many threads are allowed, and bound memory
    consumption via the queue size. If the queue fills up, events passed to the
    async-queue stream will immediately throw an exception informing you that
    the queue is full; as with all exceptions in Riemann, you can explicitly
    catch them using an exception handler stream, or allow Riemann to log the
    failure. As with all Riemann streams, exceptions don't interfere with other
    child streams.</p>

    <p>All async-queue services support hot config reloading (though they won't
    cleanly drain events between services if their parameters change), and come
    with internal metric events about their queue size, outstanding threads,
    etc. They'll alert you via state changes if they get too full, so make sure
    to monitor events like "riemann executor rejected rate" with
    <code>changed-state</code> so you'll know when they start dropping
    events.</p>

    <p>Note the bang (<code>!</code>) at the end of <code>async-queue</code>;
    this function <i>is dangerous because it mutates state</i>. Async-queue
    creates a threadpool and changes the Riemann core. You *don't* want to
    create these dynamically, or you could wind up with hundreds or thousands
    of queues and threadpools. Never put an async-queue inside of a
    <code>by</code>, for example: <code>by</code> would create a new async
    queue for each distinct host or service, etc. For safety, define your
    async-queue streams in a let binding, and call them wherever needed in
    <code>streams</code>. That way you'll know it's always the <i>same</i>
    executor.</p>

    <p>Remember, you can wrap <i>any</i> stream in this asynchronous layer.
    Combining batching and async-queue can dramatically improve throughput;
    sometimes by several orders of magnitude. Each has its cost: batching
    increases latency, and async-queue means dropping events if the queue fills
    up. As a transient event processor, Riemann emphasizes *dropping* old data
    rather than getting backed up or shutting down entirely. Think of
    async-queue like a safety valve; allowing you to still process requests by
    shunting some of the incoming stream aside. If you want <i>guaranteed</i>
    delivery over long timescales, use an on-disk queuing system like Kafka,
    either in front of or behind Riemann.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(let [index (index)
      downstream (async-queue!
                    :agg-forwarder        ; A name for the forwarder
                    {:queue-size     1e4  ; 10,000 events max
                     :core-pool-size 1    ; Minimum 4 threads
                     :max-pools-size 100} ; Maxium 100 threads
                    (forward
                      (riemann.client/tcp-client :host "127.0.0.1")))]
  (streams
    index
    ; We'll accumulate batches of at most 100 events every 10th of a second
    ; before sending those events downstream to the other Riemann node, via
    ; the async queue.
    (batch 100 1/10
      downstream)))
{% endhighlight %}
  </div>
</div>

<h2>Working with the dashboard</h2>

<h3>Application specific host grouping</h3>
<p>
It is generally desirable to group all the hosts for a specific service into a
single dashboard view. For example, all the web servers are in single view while
all the database servers are in another view.
</p>

<p>
This is usually not an issue when you are sending custom metrics using Riemann
client. However, there are cases where you are using something that you do not
control how the metrics are being sent. i.e., Riemann-tools.
</p>

<p>
Since Riemann-tools scripts are application agnostic, in order for the
dashboard view to group hosts, we must inject some application specific
information into the tags field. Tags is a collection of arbitrary strings.
In the case of Riemann-tools scripts you can pass in arbitrary strings on the
command line.
</p>

<p>
  <code>riemann-health --host 127.0.0.1 --tag "prod" --tag "webserver"</code>
</p>

<p>In this case, the above health check will include two extra tags "prod" and
"webserver". On the dashboard side, you can create a grid view which contains
the following query: </p>

<p><code>(tagged "prod" and tagged "webserver")</code></p>

<p>The tagged keyword in the query ensures that the given tag is present in the
list of tags for a given event. This query will return only "prod" and
"webservers" hosts.</p>

<h2>Integrating with other systems</h2>

<div class="row">
  <div class="sixcol">
    <p>Make sure to check the <a href="#asynchronous-streams">asynchronous
      streams</a> docs; it may be appropriate to batch or defer events which
    flow to downstream systems.</p>
  </div>
</div>

<h3>Send email</h3>

<p><code>riemann.email</code> can send single events--or vectors of events--via email:</p>

{% highlight clj %}
(let [email (mailer {:from "riemann@trioptimum.com"})]
  (streams
    (where (state "critical")
      (email "shodan@tauceti.five"))))
{% endhighlight %}

<p>You can use any options for <a href="https://github.com/drewr/postal">Postal</a>:</p>

{% highlight clj %}
(mailer {:from "riemann@trioptimum.com"
         :host "mx1.trioptimum.com"
         :user "foo"
         :pass "bar"})
{% endhighlight %}

<h3>Forward to Graphite</h3>

<p>First, you define a client to graphite, which maintains a connection pool:</p>

{% highlight clj %}
(def graph (graphite {:host "my.graphite.server"}))
{% endhighlight %}

<p>Then, use the client as a stream:</p>

{% highlight clj %}
(streams
  (where (service "thing-to-graph")
    graph))
{% endhighlight %}

<p>Or just graph everything:</p>

{% highlight clj %}
(streams
  graph)
{% endhighlight %}

<h3>Forward to Librato Metrics</h3>

<p>Create a client for librato-metrics with your username and API key:</p>

{% highlight clj %}
(def librato (librato-metrics \"aphyr@aphyr.com\" \"abcd01234...\"))
{% endhighlight %}

<p>Then use it in streams:</p>

{% highlight clj %}
(streams
  (tagged \"latency\" (librato :gauge)))
{% endhighlight %}

<p>You can submit events as annotations too. See the <a href="api/riemann.librato.html#var-librato-metrics">librato-metrics documentation</a>.</p>

<h3>Notify with Pagerduty</h3>

<p>Create a client with your pagerduty service key, then use <code>:trigger</code> and <code>:resolve</code> to open and close issues for a given host and service:</p>

{% highlight clj %}
(let [pd (pagerduty "my-service-key")]
  (streams
    (changed-state
      (where (state "ok")
        (:resolve pd)
        (else (:trigger pd))))))
{% endhighlight %}

<h3>Forward between Riemann servers</h3>

<p>When you have *many* events, you can use multiple Riemann servers to scale
out. You might, for instance, run one Riemann server per datacenter, and
forward only state changes in each service to a master server for a birds-eye
view.</p>

{% highlight clj %}
(streams
  (let [client (tcp-client :host "aggregator")]
    (by [:host :service]
       (changed :state
                (forward client)))))
{% endhighlight %}

<h2>Contributing to Riemann</h2>

<h3>Write a client</h3>

<p>A TCP connection to Riemann is a stream of messages. Each message is a 4
byte network-endian integer *length*, followed by a Protocol Buffer Message of
*length* bytes. See the <a
  href="https://github.com/aphyr/riemann-java-client/blob/master/src/main/proto/riemann/proto.proto">protocol
  buffer definition</a> for the details.</p>

<p>Over UDP, the length header is omitted; just send the protobuf Message
directly. UDP datagrams have a default maximum size of 16384 bytes by
Riemann's default; larger messages should go over TCP. This limit is
configurable in both the client and server; client values *must* be smaller
than the server's.</p>

<p>The server will accept a repeated list of Events, and respond with a
confirmation message with either an acknowledgement or an error. Check the `ok`
boolean in the message; if false, message.error will be a descriptive
string.</p>

<p>Because protocol buffers is strongly typed, the metric of an event is
represented as one of metric_d (floating point 64-bit), metric_f (floating
point 32-bit), or metric_sint64 (64-bit signed integer). Your client should emit
and consume all of these types. For compatibility with older versions of
Riemann, you may *also* emit a metric_f alongside the normal type; newer
versions of Riemann will prefer the higher-resolution types.</p>

<p>Events are uniquely identified by host and service. Both allow null.
Event.time is the time in unix epoch seconds and is optional. The server will
generate a time for each event when received if you do not provide one. I don't
need time resolution finer than 1 second presently, but if you do, my plan is
to add a nanosecond field as well.</p>

<p>You can also query events from the index using a basic query language. Just
submit a Message with your query in message.query.string. Search queries will
return a message with repeated Events matching that expression. A null
expression will return no states. For some example queries, see <a
  href="https://github.com/aphyr/riemann/blob/master/test/riemann/query_test.clj">The
  query test suite</a>.</p>

<p>You might find it useful to read the <a
  href="https://github.com/aphyr/riemann-ruby-client">Ruby client</a> source as
a guide to writing your own client.</p>

<h3>Work with the Riemann source</h3>

<p>I try to keep master as clean and runnable as possible. Riemann has an
exhaustive test suite, which helps ensure code quality. If you plan on changing
the Riemann source, fork it on Github so you'll be able to send pull requests
quickly. If you just want to run the latest version, go ahead and clone the
official repo:</p>

{% highlight sh %}
git clone git://github.com/aphyr/riemann.git
cd riemann
{% endhighlight %}

<p>You'll also need a JVM, and <a
  href="https://github.com/technomancy/leiningen">leiningen 2</a>--the Clojure
build system.</p>

<p>To run the tests suite, try <code>lein test</code>. To start Riemann, run
<code>lein run</code>. Riemann will read the file <code>riemann.config</code>
in the current directory. If you want to run a different config file, try</p>

{% highlight sh %} lein run -- path/to/my/riemann.config {% endhighlight %}

<p>If you want a fat jar, run <code>lein uberjar</code> and copy
target/riemann-{version}-STANDALONE.jar. To build tarball and debian packages,
use <code>lein pkg</code>; .debs and .tar.gz files, plus md5sums, will appear
in <code>target/</code>.

<p>The protocol buffer codec and clojure client live in <a
  href="https://github.com/aphyr/riemann-clojure-client">riemann-clojure-client</a>,
which wraps the java protobuf code and java client in <a
  href="https://github.com/aphyr/riemann-java-client">riemann-java-client</a>.
Both of these are available on clojars and most of the time you can ignore
them. However, if you need to change the protocol or client, you can fork these
projects and make your changes there.</p>

<h3>Building riemann-java-client</h3>

<p>You'll need maven, and the protocol buffers compiler (protoc) version
2.4.1.</p>

<p>When you've made changes to the java client, install it with <code>mvn
  install</code>; then test the clojure client and install it with <code>lein
  install</code>. Finally, you can run riemann itself. You may need to check
that the client versions you're working with match up in the riemann and
riemann-clojure-clientproject.clj files.</p>

<h3>Fix a bug or add a feature</h3>

<p>First, <a href="https://github.com/aphyr/riemann">fork Riemann on
  github</a>. Clone your fork and create a new topic branch for your fix:</p>

{% highlight sh %}
git clone git@github.com:your-github-username/riemann.git
cd riemann
git checkout -b fix-some-bug
{% endhighlight %}

<p>Most of Riemann's source lives in <code>src/riemann/</code>. Corresponding
tests live in <code>test/riemann/test/</code>. When you fix a bug or add a
feature, make sure to add new tests that confirm its correctness! You can run
the test suite with</p>

{% highlight sh %}
lein test
{% endhighlight %}

<p>Some tests for integrating with other services require a local sendmail, or
graphite, or credentials for a web service. If you make changes that affect
these systems, you can test them with special selectors like <code>lein test
  :graphite</code> or <code>lein test :email</code>. If you're working with a
particular namespace, like <code>riemann.streams</code>, <code>lein test
  riemann.test.streams</code> runs only the tests for that namespace. Once your
tests pass, commit your changes and push them to github:</p>

{% highlight sh %}
git commit -a
git push origin fix-some-bug
{% endhighlight %}

<p>If you change more than a few lines of whitespace, please make your
formatting changes in a separate commit; it'll be easier for me to read and
understand your changes. Please try to send me only a few commits where
possible; use <code>rebase --interactive</code> to squash your small
changes.</p>

<h3>Help write documentation</h3>

<p>Riemann's web site and documentation are in the gh-pages branch of the
riemann repository. <a href="https://github.com/aphyr/riemann">Fork riemann on
  github</a>, clone your fork, and check out the branch:</p>

{% highlight sh %}
git clone git@github.com:your-github-username/riemann.git
cd riemann
git checkout gh-pages
vim howto.html
{% endhighlight %}

<p>Pages are built with Jekyll. To see how your changes will appear on the site,</p>

{% highlight sh %}
sudo apt-get install python-pygments jekyll
cd riemann
jekyll
{% endhighlight %}

<p>... and open _site/howto.html in a web browser. When you're satisfied with
your changes, commit, push, and send me a pull request:</p>

{% highlight sh %}
git commit -am "Added a howto guide for integrating with FooService"
git push
{% endhighlight %}

    </div>
  </div>
</div>
